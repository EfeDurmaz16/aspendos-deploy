// Aspendos Database Schema
// Based on aspendos_tech_spec.md Section 3.2

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER MANAGEMENT (synced from Clerk)
// ============================================

model User {
  id        String   @id @default(cuid())
  clerkId   String?  @unique // Legacy - kept for data migration, now optional
  email     String   @unique
  name      String?
  avatar    String?
  tier      Tier     @default(STARTER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  chats                    Chat[]
  messages                 Message[]
  memories                 Memory[]
  agents                   Agent[]
  billingAccount           BillingAccount?
  apiKeys                  ApiKey[]
  scheduledTasks           ScheduledTask[]
  pushSubscriptions        PushSubscription[]
  notificationPreferences  NotificationPreferences?
  notificationLogs         NotificationLog[]

  emailVerified Boolean   @default(false)
  image         String?
  sessions      Session[]
  accounts      Account[]

  @@index([email])
  @@map("user")
}

enum Tier {
  STARTER
  PRO
  ULTRA
}

// ============================================
// BILLING
// ============================================

model BillingAccount {
  id                    String   @id @default(cuid())
  userId                String   @unique
  polarCustomerId       String?
  stripeCustomerId      String?
  subscriptionId        String?
  plan                  String   @default("starter") // starter, pro, ultra
  status                String   @default("active") // active, past_due, canceled
  billingCycle          String   @default("monthly") // weekly, monthly
  monthlyCredit         Int      @default(1000) // Token budget in K tokens (1M = 1000)
  creditUsed            Float    @default(0) // K tokens used
  chatsRemaining        Int      @default(300) // Chats remaining this period
  voiceMinutesRemaining Int      @default(300) // Voice minutes remaining (10 min/day * 30)
  resetDate             DateTime @default(now())
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  creditHistory CreditLog[]

  @@index([userId])
}

model CreditLog {
  id               String   @id @default(cuid())
  billingAccountId String
  amount           Int // Negative for usage, positive for refund
  reason           String // "model_inference", "memory_embedding", "media_generation", "refund"
  metadata         Json?
  createdAt        DateTime @default(now())

  account BillingAccount @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)

  @@index([billingAccountId])
}

// ============================================
// CONVERSATIONS
// ============================================

model Chat {
  id              String   @id @default(cuid())
  userId          String
  title           String   @default("New Chat")
  description     String?
  modelPreference String? // null = auto-select
  memoryScope     String   @default("global") // global, project, chat
  projectId       String?
  isArchived      Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages Message[]
  memories Memory[]

  @@index([userId])
  @@index([createdAt])
}

model Message {
  id          String   @id @default(cuid())
  chatId      String
  userId      String
  role        String // "user", "assistant"
  content     String   @db.Text
  modelUsed   String? // Which model generated this (for assistant messages)
  tokensIn    Int      @default(0)
  tokensOut   Int      @default(0)
  costUsd     Float    @default(0)
  memoryItems String[] // IDs of memories used/created
  metadata    Json? // { voice: true, modelFallback: "claude", etc }
  createdAt   DateTime @default(now())

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([chatId])
  @@index([userId])
  @@index([createdAt])
}

// ============================================
// MEMORY SYSTEM (5-Sector HMD Model)
// ============================================

model Memory {
  id             String    @id @default(cuid())
  userId         String
  chatId         String? // null = global memory
  content        String    @db.Text
  summary        String?   @db.Text // Auto-generated summary
  type           String // "context", "preference", "insight", "project" (legacy)
  sector         String    @default("semantic") // episodic, semantic, procedural, emotional, reflective
  source         String? // "user_input", "extracted", "ai_generated", "conversation"
  importance     Int       @default(50) // 1-100 scale
  confidence     Float     @default(0.8) // 0.0 - 1.0
  decayScore     Float     @default(1.0) // 1.0 = fresh, decays over time
  accessCount    Int       @default(0)
  isActive       Boolean   @default(true)
  isPinned       Boolean   @default(false)
  tags           String[]
  expiresAt      DateTime? // null = never expires
  lastAccessedAt DateTime  @default(now())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user     User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat     Chat?            @relation(fields: [chatId], references: [id], onDelete: SetNull)
  feedback MemoryFeedback[]

  @@index([userId])
  @@index([userId, sector])
  @@index([userId, isActive])
  @@index([chatId])
  @@index([type])
}

model MemoryFeedback {
  id         String   @id @default(cuid())
  memoryId   String
  userId     String
  wasHelpful Boolean
  notes      String?
  queryText  String?  @db.Text // What query triggered this memory
  createdAt  DateTime @default(now())

  memory Memory @relation(fields: [memoryId], references: [id], onDelete: Cascade)

  @@index([memoryId])
  @@index([userId])
}

// ============================================
// AGENTS
// ============================================

model Agent {
  id           String   @id @default(cuid())
  userId       String
  name         String
  description  String?
  modelId      String   @default("gpt-4o")
  systemPrompt String?  @db.Text
  tools        Json? // Array of tool configs
  isActive     Boolean  @default(true)
  isPublic     Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ============================================
// SCHEDULED TASKS (Proactive Agentic Callback)
// ============================================

model ScheduledTask {
  id             String            @id @default(cuid())
  userId         String
  chatId         String
  triggerAt      DateTime          // When to execute
  status         ScheduledTaskStatus @default(PENDING)
  taskType       String            @default("PROACTIVE_FOLLOWUP")
  intent         String            @db.Text // What the AI promised to do
  contextSummary String?           @db.Text // Summary for context restoration
  topic          String?           // Topic of the follow-up
  tone           String            @default("friendly") // friendly, professional, encouraging
  channelPref    String            @default("auto") // auto, push, email, in_app
  metadata       Json?             // Additional task data
  executedAt     DateTime?         // When it was actually executed
  resultMessage  String?           @db.Text // The generated follow-up message
  deliveryStatus String?           // pending, delivered, opened, dismissed, failed
  errorMessage   String?           // Error if failed
  externalJobId  String?           // QStash or cron job ID
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, status])
  @@index([triggerAt])
  @@index([status, triggerAt])
  @@map("scheduled_task")
}

enum ScheduledTaskStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELED
}

// ============================================
// API KEYS
// ============================================

model ApiKey {
  id          String    @id @default(cuid())
  userId      String
  name        String
  keyHash     String    @unique // Hashed API key
  keyPrefix   String // First 8 chars for display (e.g., "aspd_abc1...")
  permissions String[] // ["chat:read", "chat:write", "memory:read"]
  lastUsedAt  DateTime?
  expiresAt   DateTime?
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([keyHash])
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

// ============================================
// NOTIFICATIONS (Phase 3: Proactive Agent Callbacks)
// ============================================

model PushSubscription {
  id         String   @id @default(cuid())
  userId     String
  endpoint   String   @db.Text // Push notification endpoint URL
  p256dh     String   @db.Text // Public key for encryption
  auth       String   @db.Text // Authentication secret
  deviceType String? // "web", "mobile", "desktop"
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("push_subscription")
}

model NotificationPreferences {
  id              String    @id @default(cuid())
  userId          String    @unique
  pushEnabled     Boolean   @default(true)
  emailEnabled    Boolean   @default(true)
  inAppEnabled    Boolean   @default(true)
  quietHoursStart String? // "22:00" format
  quietHoursEnd   String? // "08:00" format
  timezone        String    @default("UTC")
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("notification_preferences")
}

model NotificationLog {
  id          String    @id @default(cuid())
  userId      String
  type        String // "PROACTIVE_FOLLOWUP", "REMINDER", "ALERT"
  title       String
  message     String    @db.Text
  channel     String // "push", "email", "in_app"
  status      String    @default("pending") // "pending", "delivered", "opened", "dismissed", "failed"
  taskId      String? // Reference to ScheduledTask if applicable
  metadata    Json?
  deliveredAt DateTime?
  readAt      DateTime?
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, status])
  @@index([createdAt])
  @@map("notification_log")
}
