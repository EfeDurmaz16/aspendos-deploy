// Aspendos Database Schema
// Based on aspendos_tech_spec.md Section 3.2

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER MANAGEMENT (synced from Clerk)
// ============================================

model User {
  id        String   @id @default(cuid())
  clerkId   String?  @unique // Legacy - kept for data migration, now optional
  email     String   @unique
  name      String?
  avatar    String?
  tier      Tier     @default(FREE)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  chats                    Chat[]
  messages                 Message[]
  memories                 Memory[]
  agents                   Agent[]
  billingAccount           BillingAccount?
  apiKeys                  ApiKey[]
  scheduledTasks           ScheduledTask[]
  pushSubscriptions        PushSubscription[]
  notificationPreferences  NotificationPreferences?
  notificationLogs         NotificationLog[]
  importJobs               ImportJob[]
  pacReminders             PACReminder[]
  pacSettings              PACSettings?
  councilSessions          CouncilSession[]
  gamificationProfile      GamificationProfile?

  emailVerified Boolean   @default(false)
  image         String?
  sessions      Session[]
  accounts      Account[]
  passkeys      Passkey[]

  @@index([email])
  @@map("user")
}

enum Tier {
  FREE
  STARTER
  PRO
  ULTRA
}

// ============================================
// BILLING
// ============================================

model BillingAccount {
  id                    String   @id @default(cuid())
  userId                String   @unique
  polarCustomerId       String?
  stripeCustomerId      String?
  subscriptionId        String?
  plan                  String   @default("starter") // starter, pro, ultra
  status                String   @default("active") // active, past_due, canceled
  billingCycle          String   @default("monthly") // weekly, monthly
  monthlyCredit         Int      @default(1000) // Token budget in K tokens (1M = 1000)
  creditUsed            Float    @default(0) // K tokens used
  chatsRemaining        Int      @default(300) // Chats remaining this period
  voiceMinutesRemaining Int      @default(300) // Voice minutes remaining (10 min/day * 30)
  resetDate             DateTime @default(now())
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  creditHistory CreditLog[]

  @@index([userId])
}

model CreditLog {
  id               String   @id @default(cuid())
  billingAccountId String
  amount           Int // Negative for usage, positive for refund
  reason           String // "model_inference", "memory_embedding", "media_generation", "refund"
  metadata         Json?
  createdAt        DateTime @default(now())

  account BillingAccount @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)

  @@index([billingAccountId])
  @@index([billingAccountId, createdAt])
  @@index([billingAccountId, reason, createdAt])
}

// ============================================
// CONVERSATIONS
// ============================================

model Chat {
  id              String   @id @default(cuid())
  userId          String
  title           String   @default("New Chat")
  description     String?
  modelPreference String? // null = auto-select
  memoryScope     String   @default("global") // global, project, chat
  projectId       String?
  shareToken      String?  @unique
  sharedAt        DateTime?
  isArchived      Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages Message[]
  memories Memory[]

  @@index([userId])
  @@index([createdAt])
  @@index([shareToken])
  @@index([userId, createdAt])
  @@index([userId, isArchived])
}

model Message {
  id          String   @id @default(cuid())
  chatId      String
  userId      String
  role        String // "user", "assistant"
  content     String   @db.Text
  modelUsed   String? // Which model generated this (for assistant messages)
  tokensIn    Int      @default(0)
  tokensOut   Int      @default(0)
  costUsd     Float    @default(0)
  memoryItems String[] // IDs of memories used/created
  metadata    Json? // { voice: true, modelFallback: "claude", etc }
  createdAt   DateTime @default(now())

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([chatId])
  @@index([userId])
  @@index([createdAt])
  @@index([chatId, createdAt])
  @@index([userId, createdAt])
}

// ============================================
// MEMORY SYSTEM (5-Sector HMD Model)
// ============================================

model Memory {
  id             String    @id @default(cuid())
  userId         String
  chatId         String? // null = global memory
  content        String    @db.Text
  summary        String?   @db.Text // Auto-generated summary
  type           String // "context", "preference", "insight", "project" (legacy)
  sector         String    @default("semantic") // episodic, semantic, procedural, emotional, reflective
  source         String? // "user_input", "extracted", "ai_generated", "conversation"
  importance     Int       @default(50) // 1-100 scale
  confidence     Float     @default(0.8) // 0.0 - 1.0
  decayScore     Float     @default(1.0) // 1.0 = fresh, decays over time
  accessCount    Int       @default(0)
  isActive       Boolean   @default(true)
  isPinned       Boolean   @default(false)
  tags           String[]
  expiresAt      DateTime? // null = never expires
  lastAccessedAt DateTime  @default(now())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user     User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat     Chat?            @relation(fields: [chatId], references: [id], onDelete: SetNull)
  feedback MemoryFeedback[]

  @@index([userId])
  @@index([userId, createdAt])
  @@index([userId, sector])
  @@index([userId, isActive])
  @@index([chatId])
  @@index([type])
  @@index([userId, isActive, lastAccessedAt])
}

model MemoryFeedback {
  id         String   @id @default(cuid())
  memoryId   String
  userId     String
  wasHelpful Boolean
  notes      String?
  queryText  String?  @db.Text // What query triggered this memory
  createdAt  DateTime @default(now())

  memory Memory @relation(fields: [memoryId], references: [id], onDelete: Cascade)

  @@index([memoryId])
  @@index([userId])
}

// ============================================
// AGENTS
// ============================================

model Agent {
  id           String   @id @default(cuid())
  userId       String
  name         String
  description  String?
  modelId      String   @default("gpt-4o")
  systemPrompt String?  @db.Text
  tools        Json? // Array of tool configs
  isActive     Boolean  @default(true)
  isPublic     Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ============================================
// SCHEDULED TASKS (Proactive Agentic Callback)
// ============================================

model ScheduledTask {
  id             String            @id @default(cuid())
  userId         String
  chatId         String
  triggerAt      DateTime          // When to execute
  status         ScheduledTaskStatus @default(PENDING)
  taskType       String            @default("PROACTIVE_FOLLOWUP")
  intent         String            @db.Text // What the AI promised to do
  contextSummary String?           @db.Text // Summary for context restoration
  topic          String?           // Topic of the follow-up
  tone           String            @default("friendly") // friendly, professional, encouraging
  channelPref    String            @default("auto") // auto, push, email, in_app
  metadata       Json?             // Additional task data
  executedAt     DateTime?         // When it was actually executed
  resultMessage  String?           @db.Text // The generated follow-up message
  deliveryStatus String?           // pending, delivered, opened, dismissed, failed
  errorMessage   String?           // Error if failed
  externalJobId  String?           // QStash or cron job ID
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, status])
  @@index([triggerAt])
  @@index([status, triggerAt])
  @@index([status, updatedAt])
  @@map("scheduled_task")
}

enum ScheduledTaskStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELED
}

// ============================================
// API KEYS
// ============================================

model ApiKey {
  id          String    @id @default(cuid())
  userId      String
  name        String
  keyHash     String    @unique // Hashed API key
  keyPrefix   String // First 8 chars for display (e.g., "aspd_abc1...")
  permissions String[] // ["chat:read", "chat:write", "memory:read"]
  lastUsedAt  DateTime?
  expiresAt   DateTime?
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([keyHash])
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

// ============================================
// PASSKEY (WebAuthn/FIDO2 for passwordless auth)
// ============================================

model Passkey {
  id           String   @id @default(cuid())
  name         String?
  publicKey    String   @db.Text
  userId       String
  credentialID String   @unique
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  aaguid       String?
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("passkey")
}

// ============================================
// NOTIFICATIONS (Phase 3: Proactive Agent Callbacks)
// ============================================

model PushSubscription {
  id         String   @id @default(cuid())
  userId     String
  endpoint   String   @db.Text // Push notification endpoint URL
  p256dh     String   @db.Text // Public key for encryption
  auth       String   @db.Text // Authentication secret
  deviceType String? // "web", "mobile", "desktop"
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("push_subscription")
}

model NotificationPreferences {
  id              String    @id @default(cuid())
  userId          String    @unique
  pushEnabled     Boolean   @default(true)
  emailEnabled    Boolean   @default(true)
  inAppEnabled    Boolean   @default(true)
  quietHoursStart String? // "22:00" format
  quietHoursEnd   String? // "08:00" format
  timezone        String    @default("UTC")
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("notification_preferences")
}

model NotificationLog {
  id          String    @id @default(cuid())
  userId      String
  type        String // "PROACTIVE_FOLLOWUP", "REMINDER", "ALERT"
  title       String
  message     String    @db.Text
  channel     String // "push", "email", "in_app"
  status      String    @default("pending") // "pending", "delivered", "opened", "dismissed", "failed"
  taskId      String? // Reference to ScheduledTask if applicable
  metadata    Json?
  deliveredAt DateTime?
  readAt      DateTime?
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, status])
  @@index([createdAt])
  @@index([userId, status, createdAt])
  @@map("notification_log")
}

// ============================================
// IMPORT FEATURE (History Import from ChatGPT/Claude)
// ============================================

model ImportJob {
  id            String         @id @default(cuid())
  userId        String
  source        ImportSource
  status        ImportStatus   @default(PENDING)
  fileName      String
  fileSize      Int // In bytes
  totalItems    Int            @default(0)
  importedItems Int            @default(0)
  errorMessage  String?
  metadata      Json? // Source-specific metadata
  startedAt     DateTime?
  completedAt   DateTime?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  user     User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  entities ImportEntity[]

  @@index([userId])
  @@index([userId, status])
  @@index([createdAt])
  @@map("import_job")
}

model ImportEntity {
  id         String           @id @default(cuid())
  jobId      String
  type       ImportEntityType
  externalId String // Original ID from source platform
  title      String?
  content    Json // Full conversation/entity content
  selected   Boolean          @default(true) // User can deselect items
  imported   Boolean          @default(false)
  chatId     String? // Reference to created Chat after import
  errorMsg   String?
  createdAt  DateTime         @default(now())

  job ImportJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@unique([jobId, externalId])
  @@index([jobId])
  @@index([jobId, selected])
  @@map("import_entity")
}

enum ImportSource {
  CHATGPT
  CLAUDE
  GEMINI
  OTHER
}

enum ImportStatus {
  PENDING
  UPLOADING
  PARSING
  PREVIEWING
  IMPORTING
  COMPLETED
  FAILED
  CANCELED
}

enum ImportEntityType {
  CONVERSATION
  MESSAGE
  ATTACHMENT
  MEMORY
}

// ============================================
// PAC FEATURE (Proactive AI Callbacks)
// ============================================

model PACReminder {
  id            String         @id @default(cuid())
  userId        String
  type          ReminderType
  content       String         @db.Text
  triggerAt     DateTime
  status        ReminderStatus @default(PENDING)
  source        String? // "explicit" (user said "remind me") or "implicit" (detected commitment)
  sourceText    String?        @db.Text // Original text that triggered this reminder
  chatId        String? // Reference to source conversation
  priority      Int            @default(50) // 1-100
  deliveredAt   DateTime?
  respondedAt   DateTime?
  responseType  String? // "acknowledged", "snoozed", "dismissed"
  snoozeCount   Int            @default(0)
  metadata      Json?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  escalations PACEscalation[]

  @@index([userId])
  @@index([userId, status])
  @@index([triggerAt])
  @@index([status, triggerAt])
  @@index([userId, createdAt])
  @@map("pac_reminder")
}

model PACEscalation {
  id          String   @id @default(cuid())
  reminderId  String
  level       Int      @default(1) // 1, 2, 3 escalation levels
  channel     String // "push", "email", "sms"
  scheduledAt DateTime
  sentAt      DateTime?
  status      String   @default("pending") // "pending", "sent", "failed"
  createdAt   DateTime @default(now())

  reminder PACReminder @relation(fields: [reminderId], references: [id], onDelete: Cascade)

  @@index([reminderId])
  @@index([scheduledAt])
  @@map("pac_escalation")
}

model PACSettings {
  id                String   @id @default(cuid())
  userId            String   @unique
  enabled           Boolean  @default(true)
  explicitEnabled   Boolean  @default(true) // "remind me" style requests
  implicitEnabled   Boolean  @default(true) // Detected commitments
  pushEnabled       Boolean  @default(true)
  emailEnabled      Boolean  @default(true)
  smsEnabled        Boolean  @default(false)
  quietHoursStart   String? // "22:00" format
  quietHoursEnd     String? // "08:00" format
  timezone          String   @default("UTC")
  minPriority       Int      @default(30) // Only notify for priority >= this
  escalationEnabled Boolean  @default(true)
  digestEnabled     Boolean  @default(true) // Daily digest of upcoming reminders
  digestTime        String   @default("09:00")
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("pac_settings")
}

enum ReminderType {
  EXPLICIT // User explicitly asked to be reminded
  IMPLICIT // AI detected a commitment
  FOLLOWUP // AI proactively following up on a topic
  SCHEDULED // Time-based scheduled reminder
}

enum ReminderStatus {
  PENDING
  SCHEDULED
  DELIVERED
  ACKNOWLEDGED
  SNOOZED
  DISMISSED
  EXPIRED
  FAILED
}

// ============================================
// COUNCIL FEATURE (Multi-Model Parallel Querying)
// ============================================

model CouncilSession {
  id              String            @id @default(cuid())
  userId          String
  chatId          String? // Optional link to a chat conversation
  query           String            @db.Text
  status          CouncilStatus     @default(PENDING)
  selectedPersona String? // Which persona's response was selected
  synthesis       String?           @db.Text // Combined synthesis of all responses
  totalLatencyMs  Int               @default(0)
  metadata        Json?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  responses CouncilResponse[]

  @@index([userId])
  @@index([userId, createdAt])
  @@map("council_session")
}

model CouncilResponse {
  id        String         @id @default(cuid())
  sessionId String
  persona   PersonaType
  modelId   String // e.g., "claude-3-sonnet", "gpt-4", "gemini-pro", "llama-3"
  content   String         @db.Text
  latencyMs Int            @default(0)
  tokensIn  Int            @default(0)
  tokensOut Int            @default(0)
  status    ResponseStatus @default(PENDING)
  errorMsg  String?
  rating    Int? // 1-5 user rating
  selected  Boolean        @default(false)
  createdAt DateTime       @default(now())

  session CouncilSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([sessionId, persona])
  @@index([sessionId, selected])
  @@map("council_response")
}

enum CouncilStatus {
  PENDING
  QUERYING
  STREAMING
  SYNTHESIZING
  COMPLETED
  FAILED
  CANCELED
}

enum PersonaType {
  SCHOLAR // Analytical, data-driven (Claude)
  CREATIVE // Innovative, out-of-the-box (GPT-4)
  PRACTICAL // Cautious, risk-aware (Gemini)
  DEVILS_ADVOCATE // Fast, efficient (Groq/Llama)
}

enum ResponseStatus {
  PENDING
  STREAMING
  COMPLETED
  FAILED
  TIMEOUT
}

// ============================================
// GAMIFICATION SYSTEM
// ============================================

model GamificationProfile {
  id               String   @id @default(cuid())
  userId           String   @unique
  totalXp          Int      @default(0)
  level            Int      @default(1)
  currentStreak    Int      @default(0)
  longestStreak    Int      @default(0)
  lastActiveDate   DateTime @default(now())
  streakFreezes    Int      @default(1) // Free tier gets 1, Pro gets 3
  freezesUsed      Int      @default(0)
  referralCode     String   @unique
  referredBy       String? // userId of referrer
  totalReferrals   Int      @default(0)
  proDaysEarned    Int      @default(0) // From referrals
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievements Achievement[]
  xpLogs       XPLog[]

  @@index([referralCode])
  @@map("gamification_profile")
}

model Achievement {
  id          String    @id @default(cuid())
  profileId   String
  code        String // e.g., "first_chat", "streak_7", "council_master"
  unlockedAt  DateTime  @default(now())
  notified    Boolean   @default(false)

  profile GamificationProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, code])
  @@index([profileId])
  @@map("achievement")
}

model XPLog {
  id        String   @id @default(cuid())
  profileId String
  amount    Int
  action    String // e.g., "send_message", "complete_conversation", "use_council"
  metadata  Json?
  createdAt DateTime @default(now())

  profile GamificationProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([profileId])
  @@index([profileId, createdAt])
  @@map("xp_log")
}

// ============================================
// AUDIT LOG (Security & Compliance)
// ============================================

model AuditLog {
  id         String   @id @default(cuid())
  userId     String
  action     String // e.g., "ACCOUNT_DELETE", "DATA_EXPORT", "LOGIN", "SETTINGS_UPDATE"
  resource   String // e.g., "user", "memory", "billing"
  resourceId String?
  ip         String?
  metadata   Json?
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_log")
}
